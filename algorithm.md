# 正则演化算法过程
### 输入：strings, elements, labels, stopwords
% strings: 一组字符串  
% elements: 每个字符串的分词列表组成的列表  
% labels: 每个字符串的对应 label 组成的列表，label 为 0 或 1  
% stopwords: 停用词集合  
### 算法目标
得到一组正则表达式，能较好地区分 label 分别为 0 和 1 的两类字符串

---

### 算法过程
##### 超参数
	pop_num 种群大小 
    dim 编码长度
    [min, max] 编码的取值区间
    max_gen 最大代数
    crossover_rate 杂交比率
    mutate_rate 变异比率
    mul_0 容错度参数
	voc_n 取词参数
    repeat_rate 构造正则表达式元素时加入''和'.*'的比例

##### 过程
1. **取词:** 去掉分词中的停用词，计算每个词在两类字符串中出现的频率，计算频率差，取频率差最大的前 voc_n 个，作为构成正则表达式元素的词。
2. **构造正则元素集合:** 对于以上所得到的每个词 v，构成形式为`'(v)+'`的正则表达式元素；再加入数量为 voc_n\*repeat_rate 的空字符`''`和通配符`'.*'`，构成正则表达式的元素集合。
3. **编码映射:** 将以上所得元素与 [min,max] 上的无符号整数对应，实验中取 [0,65535] 。
4. 设置集合 best_patterns 为空集，存储各代得到的最好的正则表达式。设置正则表达式组 valid_patterns 为空集。
4. **初始化种群:** 初始化种群为 pop_num\*dim 维的矩阵 p，p 中的每个元素 p[i][j] 都是 [min,max] 区间上的随机数，p 中的每一行 p[i] 代表一个个体。
5. **对每个个体计算适应值**
	- 对个体解码得到对应的正则表达式，去除其中多余的`'.*'`
	- 以该正则表达式匹配 strings，在 label 为 1 的字符串中匹配到的总长度为 matchlen_1，在 label 为 0 的字符串中匹配到的总长度为 matchlen_0，则取该正则表达式的适应值为 matchlen_1-mul_0\*matchlen_0。
	- 求得所有个体的适应值后，对较长的正则表达式进行惩罚。即对于适应值相同的正则表达式，使越长的适应值越低，同时保持原本适应值不同的个体之间的序。
6. **更新正则表达式组:** 
	- 将个体按适应值从大到小排序。
	- 找第一个对应正则表达式不在 best_patterns 中的个体，将该正则表达式加入 best_patterns。
	- 若将该正则表达式加入正则表达式组 valid_patterns 中后能更好地区分两类字符串，则将其加入 valid_patterns，否则不加入。
	- 若所得到的正则表达式组已能较好地区分两类字符串或当前代数已达到最大代数限制，则返回 valid_patterns。
7. **轮盘赌选择保留 pop_num 个个体:** 先去除对应 pattern 相同而编码不同的重复个体，然后通过轮盘赌选择，保留 pop_num 个个体。
8. **杂交操作** 取 pop_num\*crossover_rate 个个体作为父体并杂交，将子代加入种群。
9. **变异操作** 取 pop_num\*mutate_rate 个个体进行变异，将变异后的个体加入种群。
10. 转向 6。
